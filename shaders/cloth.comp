#version 430

layout(local_size_x = 5, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 1) buffer clothBuffer {
    vec4 pos[];
};

layout(std430, binding = 2) buffer adjBuffer {
    float adjacents[];
};

layout(std430, binding = 4) buffer normalsBuffer {
    vec4 normals[];
};

layout(std430, binding = 6) buffer forcesBuffer {
    vec4 forces[];
};

layout(std430, binding = 7) buffer velocitiesBuffer {
    vec4 vel[];
};

layout(std430, binding = 8) buffer adjBuffer2 {
    float adjacents2[];
};

// Posição da esfera (xyz) controlada pela interface
uniform vec4 sphere_pos;
// Escala da esfera (usamos x como raio)
uniform vec4 sphere_scale;

uniform float timer;
uniform int width;
uniform int height;
uniform float stiffness;
uniform float stiffness2;
uniform float damping_coeff;
uniform float M;
uniform float time_interval;
uniform float marbel_radius;

vec3 hookes_law(vec3 p1, vec3 p2, float stiffness, float edge_distance) {
    vec3 v = p1 - p2;
    float l = length(v);
    vec3 vec_dir = normalize(v);
    vec3 x = (l - edge_distance) * vec_dir;
    return -stiffness * x;
}

vec3 damping_force(vec3 p1, vec3 p2, vec4 vel1, vec4 vel2, float damping_coeff) {
    vec3 vec = p1 - p2;
    vec3 vel = vel1.xyz - vel2.xyz;
    vec3 vec_dir = normalize(vec);
    vec3 x = ((vel * vec) / length(vec)) * vec_dir;
    return -damping_coeff * x;
}

// Verifica se o vértice está numa das pontas (cantos da primeira linha z=0)
bool is_top_corner(int index) {
    int x = index % width;
    int z = index / width;
    return (z == 0) && (x == 0 || x == width - 1);
}

bool is_adjacent(int index, int is_adj) {
    int x = index % width;
    int z = index / width;

    for (int j = 0; j < 3; j++) {
        for (int i = 0; i < 3; i++) {
            if (adjacents[(index * 9) + i + j * 3] > 0 && x + i - 1 + ((z + j - 1) * width) == is_adj) {
                return true;
            }
        }
    }
    return false;
}

void main() {
    int index = int(gl_GlobalInvocationID.x);
    int x = int(index) % width;
    int z = int(index) / width;

    // PONTAS FIXAS: Oscilam no eixo Z para criar movimento sobre a esfera
    if (is_top_corner(index)) {
        vel[index] = vec4(0.0);
        forces[index] = vec4(0.0);
        
        // Período de warm-up: pano fica parado para estabilizar antes de oscilar
        float warmup_time = 5000.0; 
        float effective_timer = max(0.0, timer - warmup_time);
        
        // Animação dos cantos - oscilam no eixo Z (só após warm-up)
        float oscillation_amplitude = 8.0;
        float oscillation_speed = 0.0003;
        float offset_z = -sin(effective_timer * oscillation_speed) * oscillation_amplitude;
        
        // Posição base do canto (calculada a partir do índice)
        float base_x = float(x) * (10.0 / float(width - 1));
        float base_z = 0.0;
        
        // Atualiza posição com oscilação no eixo Z
        pos[index] = vec4(base_x, 0.0, base_z + offset_z, 1.0);
        
        // Calcula as normais para iluminação correta
        vec3 currentPos = pos[index].xyz;
        vec3 vertexNormal = vec3(0.0);
        
        bool hasLeft = (x > 0);
        bool hasRight = (x < width - 1);
        bool hasDown = (z < height - 1);
        
        vec3 left = hasLeft ? pos[index - 1].xyz : currentPos;
        vec3 right = hasRight ? pos[index + 1].xyz : currentPos;
        vec3 down = hasDown ? pos[index + width].xyz : currentPos;
        
        if (hasRight && hasDown) {
            vertexNormal += cross(right - currentPos, down - currentPos);
        }
        if (hasDown && hasLeft) {
            vertexNormal += cross(down - currentPos, left - currentPos);
        }
        
        if (length(vertexNormal) > 0.001) {
            normals[index] = vec4(normalize(vertexNormal), 0.0);
        } else {
            normals[index] = vec4(0.0, 1.0, 0.0, 0.0);
        }
        return;
    }

    // Posição da esfera (lida do SCENE TRANSLATE via interface)
    vec3 sphereCenter = sphere_pos.xyz;
    // Raio de colisão = escala visual + pequena margem
    float sphereRadius = sphere_scale.x + 0.02;

    vec3 force = vec3(0.0);

    // Gravidade
    force += vec3(0.0, -9.8, 0.0) * M;

    // Forças de mola dos vizinhos adjacentes
    for (int j = 0; j < 3; j++) {
        for (int i = 0; i < 3; i++) {
            if (adjacents[(index * 9) + i + j * 3] > 0) {
                vec3 f = hookes_law(pos[index].xyz, pos[x + i - 1 + ((z + j - 1) * width)].xyz, stiffness, adjacents[(index * 9) + i + j * 3]) + damping_force(pos[index].xyz, pos[x + i - 1 + ((z + j - 1) * width)].xyz, vel[index], vel[x + i - 1 + ((z + j - 1) * width)], damping_coeff);
                force += f;
            }
        }
    }

    // Forças de mola secundárias (bending)
    if (adjacents2[index * 4] > 0) {
        vec3 f = hookes_law(pos[index].xyz, pos[x - 2 + z * width].xyz, stiffness2, adjacents2[index * 4]);
        force += f;
    }
    if (adjacents2[index * 4 + 1] > 0) {
        vec3 f = hookes_law(pos[index].xyz, pos[x + 2 + z * width].xyz, stiffness2, adjacents2[index * 4 + 1]);
        force += f;
    }
    if (adjacents2[index * 4 + 2] > 0) {
        vec3 f = hookes_law(pos[index].xyz, pos[x + (z - 2) * width].xyz, stiffness2, adjacents2[index * 4 + 2]);
        force += f;
    }
    if (adjacents2[index * 4 + 3] > 0) {
        vec3 f = hookes_law(pos[index].xyz, pos[x + (z + 2) * width].xyz, stiffness2, adjacents2[index * 4 + 3]);
        force += f;
    }

    if (length(force) < 0.001) force = vec3(0.0);

    // Integração de Euler
    vec3 a = force / M;
    vec3 new_vel = vel[index].xyz + a * time_interval;
    vec4 new_pos = pos[index] + vec4(new_vel * time_interval, 0.0);

    // Colisão entre vértices (self-collision)
    for (int i = 0; i < height * width; i++) {
        if (i != index && !is_adjacent(index, i) && length(new_pos.xyz - pos[i].xyz) < 2 * marbel_radius) {
            vec3 n = normalize(new_pos.xyz - pos[i].xyz);
            new_pos.xyz = pos[i].xyz + n * 2 * marbel_radius;
            float vel_along_n = dot(new_vel, n);
            if (vel_along_n < 0.0) {
                new_vel -= vel_along_n * n * 1.2;
            }
        }
    }

    // Colisão com esfera
    if (sphereRadius > 0.01 && length(new_pos.xyz - sphereCenter) < sphereRadius) {
        vec3 collision_normal = normalize(new_pos.xyz - sphereCenter);
        new_pos.xyz = sphereCenter + collision_normal * (sphereRadius + 0.01);
        
        float vel_towards_sphere = dot(new_vel, collision_normal);
        if (vel_towards_sphere < 0.0) {
            new_vel -= vel_towards_sphere * collision_normal * 1.5;
        }
        new_vel *= 0.85;
    }

    // Atualiza buffers
    forces[index] = vec4(force, length(force));
    pos[index] = new_pos;
    vel[index] = vec4(new_vel, 0.0);
    
    // Calcula normal do vértice
    vec3 vertexNormal = vec3(0.0);
    vec3 currentPos = new_pos.xyz;
    
    bool hasLeft = (x > 0);
    bool hasRight = (x < width - 1);
    bool hasUp = (z > 0);
    bool hasDown = (z < height - 1);
    
    vec3 left = hasLeft ? pos[index - 1].xyz : currentPos;
    vec3 right = hasRight ? pos[index + 1].xyz : currentPos;
    vec3 up = hasUp ? pos[index - width].xyz : currentPos;
    vec3 down = hasDown ? pos[index + width].xyz : currentPos;
    
    if (hasLeft && hasUp) {
        vertexNormal += cross(left - currentPos, up - currentPos);
    }
    if (hasUp && hasRight) {
        vertexNormal += cross(up - currentPos, right - currentPos);
    }
    if (hasRight && hasDown) {
        vertexNormal += cross(right - currentPos, down - currentPos);
    }
    if (hasDown && hasLeft) {
        vertexNormal += cross(down - currentPos, left - currentPos);
    }
    
    if (length(vertexNormal) > 0.001) {
        normals[index] = vec4(normalize(vertexNormal), 0.0);
    } else {
        normals[index] = vec4(0.0, 1.0, 0.0, 0.0);
    }
}
